Este filtro consiste b\'asicamente en dados un color y una distancia pasados como par\'ametros, procesa cada pixel de una im\'agen a color evaluando si 
el color del mismo se "aleja" m\'as de la distancia del par\'ametro, y si eso pasa, el pixel se transforma a escala de grises, sino lo mantiene igual. 
Esto logra el efecto de resaltar un color en una im\'agen

\subsubsection{Implementación en C}
Mediante dos ciclos anidados, se va recorriendo la im\'agen por cada componente de color de cada pixel. Por cada pixel se levantan sus 3 colores RGB para 
calcular la distancia a los 3 colores RGB pasados por par\'ametro. Si el color de la im\'agen supera esa distancia, entonces en el pixel que se est\'a 
procesando quedan sus 3 colores iguales, logrando una escala de grises. Si el color no supera la distancia, debe mantenerse tal cual, logrando as\'i ser 
resaltado.

\subsubsection{Implementación en Assembler}
Haciendo uso de los registros \emph{XMM} por cada acceso a memoria se pueden traer 16 bytes lo cual la cantidad de accesos a memoria decrementa 
considerablemente. Esto podr\'a apreciarse en la secc\'on de resultados.\newline
Al levantar los 16 bytes, lo primero que realizo es copiar estos 16 bytes en otros 2 registros \emph{XMM} para luego ordernarlos mediante la instrucc\'on
de Shuffle para que queden de la siguiente forma:

\begin{center}
%Poner imagen de los tres alineados. 
\end{center}

Luego le restamos a cada uno de los datos dentro de nuestros registros, un valor rc, bc o gc que es pasado por par\'matro, seg\'un se explica al
comienzo de esta secci\'on. Una considera\'on que vale la pena aclarar es que la resta es una diferencia absoluta. Este recaudo se tuvo que tomar dado 
que los bytes de la matriz son \emph{unsigned char} con lo cual si restabamos a un valor mas chico un valor mas grande esto pod\'ia confundirse y dejarnos
un valor que de ser una resta con sino ser\'ia v\'alido pero para nosotros no era util. Siendo esto, se toma compara el valor m\'as grande de cada dato
dentro del registro y el mas chico y se separan ambos en dos registros distintos. Luego se hace una resta del modo MAX - MIN dejando la resta sin signo
como quer\'iamos. A modo de ejemplo dejamos la siguiente imagen:

\begin{center}
 %poner imagen de la resta.
\end{center}

Una vez hecha la resta, se procede a convertir a float ya que las siguientes operaciones son multiplicaci\'on, suma y raiz cuadrada para la cual necesitamos
convertir nuestros datos a Float. La cuenta realizada por cada pixel es la siguiente:

\begin{center}
 $\sqrt{(r - rc)^2 + (g - gc)^2 + (b - bc)^2}$
\end{center}

Al final de toda la operaci\'on dejamos en 2 registros los 5 floats con cada una de estas operaciones en cada pixel. La siguiente imagen queda a forma de
entendimiento:

\begin{center}
 %Meter |cuenta | cuenta | cuenta | cuenta |
 % | cuenta | 0 | 0 | 0| 
\end{center}
 Un vez qu tenemos estos valores y luego de convertirlos a INT de tamaño Double word. Mediante el uso de la instrucci\'on PCMPGTD, comparamos que datos son
mayores y cuales son menores o iguales al valor pasado por parametro \emph{threshold} generando una mascara con valores 0xffffffff si el resultado de la 
operaci\'on dio \emph{true} y 0x0 en otro caso.\newline
Ya con esta m\'ascara generada, copiamos en 2 registros los valores originales de la matriz, y dejamos en uno los valores que queremos procesar usando la
instrucci\'on PAND y en otro los valores que queremos dejar como est\'an en el original usando PXOR de la m\'ascara y un PAND contra el registro. De esta
 manera negamos la m\'ascara y nos quedamos con los otros.\newline
Para terminar, procesamos los datos que debemos realizar la siguiente cuenta en para cada pixel:

\begin{center}
 $\frac{b + g + r}{3}$
\end{center}



\subsubsection{Resultados}
