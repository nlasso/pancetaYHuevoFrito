\index{Ap\'endices}
\section{Ap\'endices}

\subsection{Ap\'endice A:}

\input{tp2.tex} \newpage

\subsection{Ap\'endice B:}

{\Large Main.cpp}
\belowcaptionskip=-10pt
\lstset{framesep=10pt}
\begin{lstlisting}
	int n = atoi(argv[3]);
	float h = atof(argv[2]);
	int span = atoi(argv[1]);
	int pilares = 0;
	float COST = 0;
	float C = atof(argv[argc-2]);
	float FMAX = atof(argv[argc-1]);
	float len_h = span/n;
	float len_v = h;
	float len_t = sqrt((len_v)*(len_v) + (len_h)*(len_h));
	
	
	Matriz* A = new Matriz(4*n,4*n,6,6);  
	Matriz* b = new Matriz(4*n,1,4*n,4*n);
  
    for(int i=4;i<argc-2;i++){	// Lleno B
	
		float val = atof(argv[i]);
		b->cambiarValor(4*i-13,0,(-1)*val);	
	}
	//X = (h0,v0,F1,F2,F4,F5,F6,F7,...,F(4n-4),F(4n-3),F(4n-2),vn)
	
	
	float cos = len_h/len_t;
	float sen = len_v/len_t;		
	
	func.Llenar_Matriz(A,cos,sen,n);
	
	//Tengo A y b
	Matriz* x = func.Resolver_Sistema(A,b);	
	int fm = func.Fuerza_Maxima(x,FMAX,n);
	
	if(fm == -1){
		
		cout << "El puente se mantuvo firme, no fue necesario insertar pilar" << endl;	
	
		delete A;
		delete b;
		delete x;
		return 0;	
	}
	
	else{
		
		if(n>2){
		
			cout << "Insertando pilares intermedios.." << endl;					
			pilares++;
		
			if(div == x->elem(1,n-1)){ div--;}	//Casos borde
			if(div == 0){div=2;}
			if(div % 2 == 1){div++;}
			
			int sp = span - ((n-div)*len_h);
			int sp2 = span - ((div)*len_h);
			
			tuple<float,float> Pilares_Costo = func.Insertar_Pilar(b,sp,sp2,h,div,(n-div),COST,pilares,FMAX);	 //matriz con n = div y matriz con n = n-div 
			float Pf = get<0>(Pilares_Costo);
			float Cf = get<1>(Pilares_Costo);
			Cf += Pf*C;
		
			cout << "Pilares insertados: " << Pf << endl;
			cout << "Costo de la obra: " << Cf << endl;
		}
		else{ // Val de la estructura unica:
			float Cf =  2*(n-1)*len_h + (n-1)*len_v + n*len_t;
			Cf *= fm;
			cout << "Pilares insertados: " << 0 << endl;
			cout << "Costo de la obra: " << Cf << endl;
		}
	}
	

\end{lstlisting}

{\Large Funciones.cpp}
\begin{lstlisting}
Matriz* TP2::Funciones::Resolver_Sistema(Matriz* A, Matriz* b){
	
	tuple<Matriz*, Matriz*, Matriz*> fact = A->factorizacion_PLU();
	
	Matriz* P =  get<0>(fact);	
	Matriz* L =  get<1>(fact);
	Matriz* U =  get<2>(fact);

	Matriz* nB  = (*P)*b;
	Matriz* y = L->F_substitution(nB);
	Matriz* x = U->B_substitution(y);
	
	
	Matriz* PL = (*get<0>(fact))*get<1>(fact);
	Matriz* PLU = (*PL)*U;	
	delete P;
	delete L;
	delete U;
	delete nB;
	delete y;
	delete PL;
	delete PLU;	
	return x;	
};


int TP2::Funciones::Fuerza_Maxima(Matriz* x, float FMAX, int n){
	
	int fm = x->buscarMaximo(0);
	if(fm == 0){
	cout << "Fuerza Maxima Ejercida: h0 " << x->elem(0,0) << endl << endl;
	}
	else{
		if(fm == 1){
			cout << "Fuerza Maxima Ejercida: C0 " << x->elem(1,0) << endl << endl;	
		}
		else{
			if(fm == 4*n-1){			
				cout << "Fuerza Maxima Ejercida: Cn " << x->elem(4*n-1,0) << endl << endl;						
			}
			
			else{			
			cout << "Fuerza Maxima Ejercida: F" << fm << " " << x->elem(fm,0) << endl << endl;					
			}
		}
	}
	if(FMAX < (fabs(x->elem(fm,0)))){
		cout << "La fuerza ejercida por F" << fm << " supera FMAX = " << FMAX << ", la estructura no es segura!!" << endl << endl;
		return fm;
	}
	return -1;
}
\end{lstlisting}

{\Large Matriz.cpp}
\begin{lstlisting}

Matriz::Matriz(const int n,const int m, int p, int q){

	_p = p;
	_q = q;
	_fil = n;
	_col = m;
	valores =  new float*[_fil]; 
	for(int i=0; i < _fil; i++){
		valores[i] = new float [p+q+1]; 
		if(m>1){
			valores[i] += p;		
		}
	}
};

Matriz::~Matriz(){

	for(int i=0;i < _fil; i++){
		if(_col>1){
			valores[i]	-= _p;
		}
		delete[] valores[i];
	}
	delete[] valores;	
};


tuple<Matriz*, Matriz*, Matriz*> Matriz::factorizacion_PLU(){

    int f = _fil;
    Matriz* P = P->Identidad(f,_p,_q);
    Matriz* L = L->Identidad(f,_p,_q);
	L->_p = _p;
	L->_q = _q;
    Matriz* U = new Matriz (*this, _p, _q);
    for(int k=0;k< (_col-1); k++){

            Matriz* sub = U->SubMatriz(k,k);
            int maxFila = sub->buscarMaximo(0);
			maxFila = maxFila+k;
            if(maxFila > k){
                U->cambiarFilas(maxFila,k);
                P->cambiarFilas(k,maxFila);  // k o k+1..
				
                if(k > 0){
                    for(int l=0;l<k;l++){   // 0 < l < k-1  // l = 0:k-1
                        double temp = L->elem(k,l);
                        double temp2 = L->elem(maxFila,l);

                        L->cambiarValor(maxFila,l,temp);
                        L->cambiarValor(k,l,temp2);
                    }

                }
            }
            for(int i=k+1;i<_fil;i++){
	
                if(U->elem(k,k) != 0){

                    float newVal = ((U->elem(i,k)) / (U->elem(k,k)));
                    
                    L->cambiarValor(i,k,newVal);     //Valor de la L, multiplicador
                    U->cambiarValor(i,k,0);          //Valor triangulado queda en 0
                }
                for(int j= k+1;j< _col;j++){
                    float newVal = U->elem(i,j) - (L->elem(i,k) * U->elem(k,j));  //Lleno el resto de la fila
                    U->cambiarValor(i,j,newVal);

                }
            }
		
		delete sub;

    }
    L->_p = _p;
	L->_q = 0;	
    return make_tuple (P, L, U);
};
\end{lstlisting}